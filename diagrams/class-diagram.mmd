---
config:
  theme: default
  layout: elk
---
classDiagram

%% Instances
  class InstanceHeader {
    - relation_name: String
    + attributes: Vec~Attribute~
    - class_index: usize

    + new~S~(relation_name: S, attributes: Vec~Attribute~, class_index: usize) Result~InstanceHeader, Error~
    + relation_name() &str
    + number_of_attributes() usize
    + attribute_at_index(attribute_index: usize) Option~&Attribute~
    + index_of_attribute(attribute: Attribute) Option~usize~
    + class_index() usize
    + class_attribute() Attribute
    + number_of_classes() usize
  }
  InstanceHeader ..|> Serializable
  InstanceHeader "1" --* "many" Attribute : contains
  note for InstanceHeader "S: Into<<x>String>"

  class Instance {
    <<interface>>
    + weight() f64
    + set_weight(new_value: f64) Result~&#40&#41, Error~

    + number_of_attributes() usize
    + value_at_index(attribute_index: usize) Option~f64~
    + set_value_at_index(attribute_index: usize, new_value: f64) Result~&#40&#41, Error~
    + is_missing_at_index(attribute_index: usize) bool

    + attribute_at_index(attribute_index: usize) Option~&Attribute~
    + index_of_attribute(attribute: Attribute) Option~usize~

    + class_index() usize
    + class_value() f64
    + set_class_value(new_value: f64) Result~&#40&#41, Error~
    + is_class_missing() bool
    + number_of_classes() usize

    + to_vec() Vec~f64~

    + header() &InstanceHeader
  }
  Instance ..|> Clone
  Instance ..|> Copy
  Instance ..|> Display

  class DenseInstance {
    - header: &InstanceHeader
    - values: Vec~f64~
    - weight: f64

    + new(header: &InstanceHeader, values: Vec~f64~, weight: f64) Result~DenseInstance, Error~
  }
  DenseInstance ..|> Instance
  DenseInstance "many" --o "1" InstanceHeader


%% Attributes
  class Attribute {
    <<interface>>

    + name() &str
    + as_any() &dyn Any
    + arff_representation() String
  }
  note for NumericAttribute "S: Into<<x>String>"
  Attribute ..|> Serializable
  Attribute ..|> Display
  Attribute ..|> Any
  Attribute ..|> Send
  Attribute ..|> Sync


  class NumericAttribute {
    + name: String
    + values: Vec~u32~
    + new~S~(name: S) Result~NumericAttribute, Error~
  }
  NumericAttribute ..|> Attribute

  class NominalAttribute {
    - name: String
    - values: Vec~String~
    - label_to_index: HashMap~String, usize~

    + new~S~(name: S) NominalAttribute
    + with_values(name: S, values: Vec~String~, label_to_index: HashMap~String, usize~)
    + get_attribute_values() Vec~String~
    + index_of_value_mut(v: &str) Option~usize~
    + enumerate_values() Iterator~&str~
  }
  NominalAttribute ..|> Attribute
  note for NominalAttribute "S: Into<<x>String>"

  <<interface>> Serializable
  <<interface>> Copy
  <<interface>> Clone


  class Stream {
    <<interface>>
    + header(): &InstanceHeader
    + has_more_instances() bool
    + next_instance() Option~Instance~
    + restart() Result~&#40&#41, Error~
  }
  Stream "1" --o "1" InstanceHeader : uses
  Stream ..> Instance : produces

  class ArffFileStream {
    - path: PathBuf
    - reader: BufReader~File~
    - header: Arc~InstanceHeader~
    - data_start_pos: u64
    - next_line: Option~String~
    - finished: bool
    + new(path: PathBuf, class_index: usize) Result~ArffFileStream, Error~
    - fill_next_line() Result~&#40&#41, Error~
  }
  ArffFileStream ..|> Stream

  class SeaFunction {
    <<enumeration>>
    F1
    F2
    F3
    F4

    + threshold() f64
  }

  class SeaGenerator {
    - seed: u64
    - rng: StdRng
    - threshold: f64
    - balance_classes: bool
    - next_class_should_be_zero: bool
    - noise_percentage: u32
    - header: Arc~InstanceHeader~
    - concept_instances_number: Option~usize~
    - produced: usize

    + new(function: SeaFunction, balance: bool, noise_percentage: u32, concept_instances_number: Option~usize~, seed: u64) Result~SeaGenerator, Error~
    - gen_attr() f64
    - determine_class(a1: f64, a2: f64, a3: f64) u8
    - maybe_flip_with_noise(cls: u8) u8
  }
  SeaGenerator ..|> Stream
  SeaGenerator "many" --o "1" InstanceHeader
  SeaGenerator "many" --o "1" SeaFunction

  class AgrawalFunction {
    <<enumeration>>
    F1
    F2
    F3
    F4
    F5
    F6
    F7
    F8
    F9
    F10
    + as_u8() u8
    + as_index() usize
  }

  class RawAttrs {
    + salary: f64
    + comission: f64
    + age: i32
    + elevel: i32
    + car: i32
    + zipcode: i32
    + hvalue: f64
    + hyears: i32
    + loan: f64
  }

  class AgrawalGenerator {
    - seed: u64
    - rng: StdRng
    - function: AgrawalFunction
    - balance_classes: bool
    - next_class_should_be_zero: bool
    - perturb_fraction: f64
    - header: Arc~InstanceHeader~
    - max_instances: Option~usize~
    - produced: usize

    + new(function: AgrawalFunction, balance_classes: bool, perturb_fraction: f64, max_instances: Option~usize~, seed: u64) Result~AgrawalGenerator, Error~
    + new_with_id(function_id: u8, balance_classes: bool, perturb_fraction: f64, max_instances: Option~usize~, seed: u64) Result~AgrawalGenerator, Error~
    - sample_raw_attributes(rng: Rng) RawAttrs
    - maybe_perturb(a: RawAttrs)
    - determine_class(a: RawAttrs) i32
  }
  AgrawalGenerator ..|> Stream
  AgrawalGenerator "many" --o "1" InstanceHeader
  AgrawalGenerator "many" --o "1" AgrawalFunction
  AgrawalGenerator "1" --o "1" RawAttrs

  class AssetRule {
    R1
    R2
    R3
    R4
    R5
    + as_u8() u8
    + as_index() usize
  }

  class AssetNegotiationGenerator {
    - seed: u64
    - rng: StdRng
    - rule: AssetRule
    - noise_percentage: f32
    - balance_classes: bool
    - next_class_should_be_zero: bool
    - header: Arc~InstanceHeader~
    - produced: usize

    + new(rule: AssetRule, balance: bool, noise_percentage: f32, seed: u64) Result ~AssetNegotiationGenerator, Error~
    + new_with_id(rule_id: u8, balance: bool, noise_percentage: f32, seed: u64) Result ~AssetNegotiationGenerator, Error~
    - add_noise(cls: usize) usize
    - sample_indices() [usize]
  }
  AssetNegotiationGenerator ..|> Stream
  AssetNegotiationGenerator "many" --o "1" InstanceHeader
  AssetNegotiationGenerator "many" --o "1" AssetRule

  direction LR

  class PerformanceEvaluator {
    <<interface>>
    + reset()
    + add_result(example: &dyn Instance, class_votes: Vec~f64~)
    + performance() Vec~Measurement~
  }

  class PerformanceEvaluatorExt {
    - metrics(names: I) Vec~(String, Option~f64~)~
    - metric(name: &str) Option~f64~
  }
  note for InstanceHeader "I: IntoIterator<Item = &'a str>"

  PerformanceEvaluator ..|> PerformanceEvaluatorExt

  class Measurement {
    - name: String
    - value: f64
  }
  Measurement ..|> Serializable

  class Estimator {
    <<interface>>
    + add(v: f64)
    + estimation() f64
  }

  class BasicEstimator {
    - len: f64
    - sum: f64
    + add(v: f64)
    + estimation() f64
  }
  BasicEstimator ..|> Estimator
  BasicEstimator ..|> Serializable

  class BasicClassificationEvaluator {
    - weight_correct: Box~dyn Estimator~
    - row_kappa: Vec~Box~dyn Estimator~~
    - col_kappa: Vec~Box~dyn Estimator~~
    - precision: Vec~Box~dyn Estimator~~
    - recall: Vec~Box~dyn Estimator~~
    - num_classes: usize
    - weight_correct_no_change: Box~dyn Estimator~
    - weight_majority: Box~dyn Estimator~
    - last_true_class: usize
    - total_weight: f64

    + new(num_classes: usize) BasicClassificationEvaluator
  }

  BasicClassificationEvaluator ..|> PerformanceEvaluator
  PerformanceEvaluator ..> Measurement : produces

  direction LR

  class Classifier {
    <<interface>>
    + get_votes_for_instance(instance: &dyn Instance) Vec~f64~
    + get_prediction_for_instance(instance: &dyn Instance) Vec~usize~
    + set_model_context(header: InstanceHeader)
    + train_on_instance(inst: Instance)
    + get_model_measurements() Vec~Measurement~
    + context_is_compatible(orig: InstanceHeader, new: InstanceHeader) bool
  }

  class AttributeClassObserver {
    <<interface>>
    + observe_attribute_class(att_val: f64, class_val: uzize, weight: usize)
    + probability_of_attribute_value_given_class(att_val: f64, class_val: usize) Option~f64~
  }

  class LearningNode {
    <<interface>>
    + learn_from_instance(instance: Arc<dyn Instance>, hoeffding_tree: &HoeffdingTree)
  }

  class HoeffdingTree {
    - tree_root: Option<Arc<RwLock<dyn Node>>>
    - decision_node_count: usize,
    - active_leaf_node_count: usize,
    - inactive_leaf_node_count: usize,
    - growth_allowed: bool,
    - header: Option<Arc<InstanceHeader>>,
    - leaf_prediction_option: LeafPredictionOption,
    - nb_threshold_option: Option<f64>,
    - grace_period_option: usize,
    - split_criterion_option: Box<dyn SplitCriterion + Send + Sync>,
    - no_pre_prune_option: bool,
    - binary_splits_option: bool,
    - split_confidence_option: f64,
    - tie_threshold_option: f64,
    - remove_poor_atts_option: bool,
    - active_leaf_byte_size_estimate: f64,
    - inactive_leaf_byte_size_estimate: f64,
    - byte_size_estimate_overhead_fraction: f64,
    - max_byte_size_option: f64,
    - stop_mem_management_option: bool,
    + new_learning_node(initial_class_observations: Vec~usize~) Node
    + train_on_instance_impl(inst: Instance)
    + hoeffding_bound(range: usize, confidence: usize, n: usize) usize
    + attempt_to_split(node: ActiveLearningNode, parent: SplitNode, parent_idx: i32) Result~&#40&#41, Error~
    + get_votes_for_instance(inst: Instance) Vec~usize~
    + deactivate_learning_node(to_deactivate: ActiveLearningNode, parent: SplitNode, parent_branch: i32)
    + new() HoeffdingTree
  }

  class NaiveBayes {
    - observed_class_distribution: Vec~usize~
    - attribute_observers: Vec~AttributeClassObserver~
    - ensure_observers_length(num_model_atts: usize)
    - new_nominal_observer() Box~dyn AttributeClassObserver~
    - new_numeric_observer() Box~dyn AttributeClassObserver~
    - model_att_index_to_instance_att_index(model_idx: usize, class_idx: usize) usize
    + train_on_instance(inst: Instance)
    + get_votes_for_instance(inst: Instance) Vec~usize~
    + do_naive_bayes_prediction(instance: Instance, observed_class_distribution: Vec~f64~, attribute_observers: Vec~Option~Box~dyn AttributeClassObserver~~~) Vec~f64~
    + new() NaiveBayes
  }

  class Node {
    - is_leaf: bool
    - class_distribution: Vec~usize~
    + weight_seen() usize
    + is_leaf() bool
    + get_class_votes(instance: &dyn Instance, hoeffding_tree: &HoeffdingTree) Vec~f64~
    + get_observed_class_distribution() &Vec~f64~
    + get_observed_class_distribution_at_leaves_reachable_through_this_node() Vec~f64~
    + filter_instance_to_leaf(inst: Instance, parent: SplitNode, parent_branch: i32) FoundNode
  }

  class SplitNode {
    - split_test: InstanceConditionalTest
    - children: Vec~Node~
    - add_in_place(dst: Vec~usize~, src: Vec~usize~)
    - instance_child_index(instance: Arc~dyn Instance~)
    + set_child(index: usize, child: Arc~dyn Node~)
    + get_child(index: usize) Option~&Arc~dyn Node~~
    + new(split_test: Box~dyn InstanceConditionalTest~, observed_class_distribution: Vec~f64~, initial_children_len: Option~usize~) SplitNode
  }

  class ActiveLearningNode {
    - weight_seen_at_last_split_eval: usize
    + get_weight_seen() f64
    + get_weight_seen_at_last_split_evaluation() f64
    + set_weight_seen_at_last_split_evaluation(weight: f64)
  }

  class InactiveLearningNode {
    - observed_class_distribution: Vec~f64~
    + new(observed_class_distribution: Vec~f64~) InactiveLearningNode
  }

  class LearningNodeNB {
    + new(observed_class_distribution: Vec~f64~) LearningNodeNB
    + get_weight_seen() f64
    + get_weight_seen_at_last_split_evaluation() f64
    + set_weight_seen_at_last_split_evaluation(weight: f64)
  }

  class LearningNodeNBAdaptive {
    - observed_class_distribution: Vec~f64~
    - weight_seen_at_last_split_evaluation: f64
    - attribute_observers: Vec~Option~Box~dyn AttributeClassObserver~~~
    - is_initialized: bool
    - mc_correct_weight: f64
    - nb_correct_weight: f64
    + get_weight_seen() f64
    + get_weight_seen_at_last_split_evaluation() f64
    + set_weight_seen_at_last_split_evaluation(weight: f64)
    - max_index(dist: Vec~f64~) Option~usize~
    - super_learn_from_instance(instance: Arc~dyn Instance~, hoeffding_tree: &HoeffdingTree)
  }

  class InstanceConditionalTest {
    - branch_for_instance(instance: Arc~dyn Instance~) Option~i32~
    - result_known_for_instance(instance: Arc~dyn Instance~) bool
    - max_branches() usize
    - get_atts_test_depends_on() Vec~usize~
  }

  class FoundNode {
    - node: Option~Node~
    - parent: Option~SplitNode~
    - parent_branch: usize
  }

  HoeffdingTree ..|> Classifier
  NaiveBayes   ..|> Classifier

  LearningNodeNB        ..|> ActiveLearningNode
  LearningNodeNBAdaptive ..|> LearningNodeNB

  ActiveLearningNode   ..|> LearningNode
  InactiveLearningNode ..|> LearningNode
  SplitNode            ..|> Node

  HoeffdingTree --> Node
  SplitNode     --> InstanceConditionalTest
  FoundNode     --> Node
  FoundNode     --> SplitNode
  NaiveBayes    --> AttributeClassObserver

  direction LR

  class Snapshot {
    + instances_seen: u64
    + accuracy: f64
    + kappa: f64
    + ram_hours: f64
    + seconds: f64
    + extras: BTree~String, f64~
  }
  Snapshot ..|> Display

  class LearningCurve {
    - entries: Vec~Snapshot~
    + push(snap: Snapshot)
    + len() usize
    + iter() IterMut~'_, Snapshot~
    + as_slice() &[Snapshot]
    + latest() Option~Snapshot~
    + export(path, fmt: CurveFormat) Result~&#40&#41, Error~
    - export_with_delimiter(path, delimiter: char) Result~&#40&#41, Error~
    - export_json(path) Resul~&#40&#41, Error~
  }

  class CurveFormat {
    <<enumeration>>
    Csv
    Tsv
    Json
  }

  class PrequentialEvaluator {
    - learner: Box~dyn Classifier~
    - stream:  Box~dyn Stream~
    - evaluator: Box~dyn PerformanceEvaluator~

    - curve: LearningCurve

    - max_instances: Option~u64~
    - max_seconds: Option~u64~
    - sample_frequency: u64
    - mem_check_frequency: u64

    - processed: u64
    - start_time: Instant
    - last_sample_time: Instant
    - last_mem_time: Instant
    - ram_hours: f64

    - progress_tx: Option~Sender~Snapshot~~

    + new(learner: Classifier, stream: Stream, evaluator: PrequentialEvaluator, max_instances: Option~u64~, max_seconds: Option~u64~, sample_frequency: u64, mem_check_frequency: u64) Result~PrequentialEvaluator, Error~
    + with_progress(tx: Sender~Snapshot~) PrequentialEvaluator
    + run()
    + curve() &LearningCurve
  }

  PrequentialEvaluator ..> Stream                : pulls
  PrequentialEvaluator ..> Classifier           : tests/trains
  PrequentialEvaluator ..> PerformanceEvaluator : feeds
  PrequentialEvaluator "1" --* "1" LearningCurve : builds
  LearningCurve "many" --* "1" Snapshot         : contains
  LearningCurve ..> CurveFormat                 : export

